<!doctype html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rubik Cube</title>
    <style>
      body { margin: 0; display: grid; place-items: center; height: 100vh; background:#0b0b14; }
      .wrap { width: min(92vw, 520px); }
      h1 { color: #fff; font-family: system-ui; font-size: 18px; text-align:center; opacity:.85; margin: 0 0 12px; }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Scramble â†’ Resolve (Loop)</h1>
      <twisty-player
        id="cube"
        style="width: 100%; aspect-ratio: 1/1;"
        puzzle="3x3x3"
        background="none"
        control-panel="none"
        hint-facelets="none"
      ></twisty-player>
    </div>

    <script type="module">
      import "https://cdn.cubing.net/js/cubing/twisty";
      import { randomScrambleForEvent } from "https://cdn.cubing.net/js/cubing/scramble";
      import { Alg } from "https://cdn.cubing.net/js/cubing/alg";

      const player = document.getElementById("cube");

      // ====== SETTING ======
      const EVENT = "333";
      const PAUSE = 700;
      const LOOP_PAUSE = 900;
      // =====================

      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      // tunggu animasi selesai (lebih akurat daripada hitung moves)
      function waitUntilFinished(tp) {
        return new Promise((resolve) => {
          const onStatus = () => {
            // beberapa versi expose status berbeda; yang penting: selesai main.
            // kita cek beberapa kemungkinan biar lebih tahan beda versi.
            const st = tp?.viewer?.timeRange; // kadang ada, kadang nggak
            const isPlaying = tp?.playing ?? tp?.viewer?.playing;
            if (isPlaying === false || isPlaying === undefined) {
              // fallback: kalau properti playing gak ada, kita resolve setelah event dipanggil sekali
              // tapi tetap aman karena playAlg selalu diikuti PAUSE
              cleanup();
              resolve();
            } else if (!isPlaying) {
              cleanup();
              resolve();
            }
          };

          const cleanup = () => {
            tp.removeEventListener("playbackstatus", onStatus);
            tp.removeEventListener("playbackStatus", onStatus);
          };

          // twisty-player pernah pakai nama event yang beda casing.
          tp.addEventListener("playbackstatus", onStatus);
          tp.addEventListener("playbackStatus", onStatus);

          // jaga-jaga kalau event gak pernah keluar: timeout lunak
          setTimeout(() => { cleanup(); resolve(); }, 8000);
        });
      }

      async function playAlg(algStr) {
        player.alg = algStr;
        player.play();
        await waitUntilFinished(player);
      }

      async function cycle() {
        const scramble = (await randomScrambleForEvent(EVENT)).toString();
        const resolve = new Alg(scramble).invert().toString();

        await playAlg(scramble);
        await sleep(PAUSE);

        await playAlg(resolve);
        await sleep(PAUSE);
      }

      (async function loopForever() {
        while (true) {
          await cycle();
          await sleep(LOOP_PAUSE);
        }
      })();
    </script>
  </body>
</html>
